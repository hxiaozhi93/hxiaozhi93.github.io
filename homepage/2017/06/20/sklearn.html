<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="keywords" content="sklearn" />
    <meta name="description" content="overfitting" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0" />
    <title>小志同学 - sklearn</title>
    <link rel="shortcut icon" href="favicon.ico" />
    <link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/8.0/styles/sunburst.min.css" />
    <link rel="stylesheet/less" href="/homepage/assets/style/style.less" />
    <script src="https://lib.sinaapp.com/js/jquery/1.9.1/jquery-1.9.1.min.js"></script>
    <script src="https://cdn.bootcss.com/less.js/1.7.0/less.min.js"></script>
    <script src="https://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>
</head>
<body>
<script>
    var pageData = {};
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement('script');
        hm.src = 'https://hm.baidu.com/hm.js?6b9830e6ab8073ce1a44ad49a03d8596';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>
<img src="http://oij8a9ql4.bkt.clouddn.com/portrait.jpg" alt="小志同学" width="0" height="0" />
<nav>
    <a href="javascript:;" class="js_menu_btn">
        <span></span>
        <span></span>
        <span></span>
    </a>
    <ul class="js_menu">
        <li><a href="/homepage/">Home</a></li>
        <li><a href="/homepage/views/posts" class="js_goto_posts">Posts</a></li>
        <li><a href="/homepage/views/about">About</a></li>
    </ul>
</nav>
<a href="javascript:;" class="gotop js_gotop"></a>
<header class="post" style="background-image: url('http://oij8a9ql4.bkt.clouddn.com/banner.jpg')">
    <div>
        <h2>sklearn</h2>
        <time>20 Jun 2017</time>
        <p class="abstract">Python机器学习应用,无监督学习，监督学习，强化学习</p>
        <ul class="c-fix">
            
                    <li>机器学习</li>

                    <li>python</li>

                    <li>sklearn</li>
            
        </ul>
    </div>
</header>
<article class="js_article">


<hr />

<p>参考自MOOC《Python机器学习应用》北京理工大学-礼欣、嵩天</p>
<p>sklearn库基本功能：分类，回归，聚类，降维，模型选择，数据预处理</p>
<p>分类：最近邻算法/neighbors.NearestNeighbors，支持向量机/svm.SVC，朴素贝叶斯/naive_bayes.GaussianNB，决策树/tree.DecisionTreeClassifier，集成方法/ensemble.BaggingClassifier，神经网络/neural_network.MLPClassifier.</p>
<p>回归：岭回归/linear_model.Ridge，Lasso回归/linear_model.Lasso，弹性网络/linear_model.ElasticNet，最小角回归/linear_model.Lars，贝叶斯回归/linear_model.BayesianRidge，逻辑回归/linear_model.LogisticRegression，多项式回归/preprocessing.PolynomialFeatures。</p>
<p>聚类：K-means/cluster.KMeans，AP聚类/cluster.AffinityPropagation，均值漂移/cluster.MeanShift，层次聚类/cluster.AgglomerativeClustering，DBSCAN/cluster.DBSCAN，BIRCH/cluster.Birch，谱聚类/cluster.SpectralClustering。</p>
<p>降维：主成分分析/decomposition.PCA，截断SVD和LSA/decomposition.TruncatedSVD，字典学习，因子分析，独立成分分析/decomposition.FastICA，非负矩阵分解/decomposition.NMF，LDA。</p>
<p>从sklearn.datasets加载相关数据集
from sklearn.datasets import load_digits；digits=load_digits()； print(digits.data.shape)；print(digits.target.shape)
list(digits.target_names)；import matplotlib.pyplot as plt；plt.matshow(digits.images[0])；plt.show()；

digits=load_digits(return_X_y=True)，参数return_X_y为True时，以（data，target）形式返回数据，默认为False，表示以字典形式返回全部信息。
</p>
<p>无监督学习：利用无标签的数据学习数据的分布或数据与数据之间的关系。应用场景如聚类、降维等。</p>
<p>聚类算法所在模块：sklearn.cluster，标准数据输入格式：[样本个数，特征个数]定义的矩阵形式。相似性矩阵输入格式：即由[样本数目，样本数目]定义的矩阵形式，矩阵中每一个元素为两个样本的相似度，如DBSCAN,AP近邻传播算法。若以余弦相似度为例，则对角线元素全为1，其他元素取值[0,1].</p>
<p>聚类：根据数据的“相似性”将数据分为多类的过程。评估不同样本间的“相似性”，通常方法为计算两个样本间的“距离”。欧式距离，曼哈顿距离，马氏距离（表示数据的协方差距离，是一种尺度无关的度量方式），夹角余弦（用向量空间中两个向量夹角的余弦值作为衡量两个样本差异的大小），聚类算法所在模块：sklearn.cluster。</p>
<p>K-means(参数：聚类个数，可扩展性：大规模数据，相似性度量：点间距离)，DBSCAN(参数：邻域大小，可扩展性：大规模数据，相似性度量：点间距离)，Gaussian Mixtures(参数：聚类个数及其他超参，可扩展性：复杂度高，不适合处理大规模数据，相似性度量：马氏距离)，Birch(参数：分支因子，阈值等超参，可扩展性：大规模数据，相似性度量：两点间的欧氏距离)</p>
<p>PCA(参数：所降维度及其他超参，可扩展性：大规模数据，适用任务：信号处理等)，FastICA(参数：所降维度及其他超参，可扩展性：超大规模数据，适用任务：图形图像特征提取)，NMF(参数：所降维度及其他超参，可扩展性：大规模数据，适用任务：图形图像特征提取)，LDA(参数：所降维度及其他超参，可扩展性：大规模数据，适用任务：文本挖掘，主题挖掘)。</p>
<p>kmeans：km=KMeans(n_clusters=3);(创建kmeans算法实例)label=km.fit_predict(data);（调用kmeans的fit_predict方法计算簇中心以及为簇分配序号）expenses=np.sum(km.cluster_centers_,axis=1)</p>
<p>DBSCAN密度聚类：主要参数（eps：两个样本被看作邻居节点的最大距离；min_samples：簇的样本数，metric：距离计算方式）。db=skc.DBSCAN(eps=0.01,min_samples=20).fit(X);labels=db.labels_;</p>
<p>PCA降维：矩阵的主成分就是其协方差对应的特征向量，按照的特征值大小进行排序，最大的特征值就是第一主成分，其次是第二成分，以此类推。
使用sklearn.decomposition.PCA加载PCA进行降维，主要参数（n_components：指定主成分个数，即降维后数据维度；svd_solver：设置特征值分解的方法。）data=load_iris();y=data.target;x=data.data;pca=PCA(n_components=2);reduced_X=pca.fit_transform(X);</p>
<p>NMF非负矩阵分解：给定一个非负矩阵 V，NMF 能够找到一个非负矩阵 W和一个 非负矩阵 H，使得矩阵 W和H的乘积近似等于矩阵 V中的值。（w矩阵为基础图像矩阵，相当于从原矩阵V抽取出来的特征，（即可用NMF对图像数据进行特征提取）H矩阵为系数矩阵）。矩阵分解优化目标：最小化W矩阵 H矩阵的乘积和原始矩阵之间的差别。
使用sklearn.decomposition.NMF加载NMF算法，主要参数（n_components：用于指定分解后矩阵的单个维度k，init：wjuzhen和h矩阵的初始化方式默认为nndsvdar）data=load_iris();y=data.target;x=data.data;pca=PCA(n_components=2);reduced_X=pca.fit_transform(X);</p>
<p>import PIL.Image as image;f=open(filepath,'rb');img=image.open(f);m,n=img.size;for i in range (m): for j in range (n): x,y,z=img.getpixel((i,j));f.clse();</p>
<p>sklearn库中分类器未被封装在一个子模块，回归函数分装在两个子模块，分别是sklearn.linear_model(线性函数如LR，Ridge，Lasso)和sklearn.preprocessing（非线性回归函数如多项式回归PolynomialFeatures）</p>
<p>KNN：from sklearn.neighbors import KNeighborsClassifier;neigh=KNeighborsClassifier(n_neighbors=3）；neigh.fit(x,y);print(neigh.predict([[1]]));</p>
<p>决策树：sklearn.tree.DecisionTreeClassifier,主要参数（criterion：选择属性的准则，如gini代表基尼系数或entropy代表信息增益，max_features：表示从多少个特征中选择最优特征。）</p>
<p>导入计算交叉验证值得函数：from sklearn.model_selection import cross_val_score;交叉验证：from sklearn import cross_validation;</p>
<p>sklearn库实现了三个朴素贝叶斯分类器（naive_bayes.GaussianNB高斯朴素贝叶斯，naive_bayes.MultinomialNB针对多项式模型的朴素贝叶斯分类器，naive_bayes.BernoulliNB针对多元伯努利模型的朴素贝叶斯分类器，）</p>
<p>线性回归：from sklearn import linear_model;linear=linear_model.LinearRegression();linear.fit(datasets_x,datasets_y); </p>
<p>多项式回归;from sklearn.preprocessing import PolynomialFeatures;poly_reg=PolynomialFeatures(degree=2);x_poly=poly_reg.fit_transform(datasets_x);lin_reg_2=linear_odel.LinearRegression();lin_reg_2.fit(x_poly,datasets_y);
</p>
<p>岭回归：传统的基于最小二乘的线性回归缺乏稳定性，进行改良。sklearn.linear_model.Ridge,主要参数（alpha：正则化因子，fit_intercept:表示是否计算截距，solver：设置计算参数的方法）</p>
<p>神经网络：from sklearn.neural_network import MLPClassifier
</p>
<p>强化学习就是程序或智能体（ agent ）通过与环境不断地进行交互学习一 个从环境到动作的映射，学习目标就是使累计 回报 最大化。强化学习是一种试错学习，因其在各状态（环境）下需要尽量尝所有可以选择的动作，通过环境给出反馈（即奖励）来判断动作的优劣，最终获得环境和优动作的映射关系（即策略）。</p>
<P>马尔可夫决策过程（ Markov Decision tree）通常用来描述一个强化学习问题  智能体 agent 根据 当前对 环境的 观察 采取动作获得环境的 反馈 ，并使 环境 发生改变的循环过程。MDP基本元素：状态集合，动作集合，状态转移模型，agent采取某动作后的即时奖励，策略等。状态值函数：表示执行策略能得到的累计折扣奖励。状态动作值函数：表示在状态s下执行动作a能得到的累计折扣奖励。</P>
<p>在现实的强化学习任务中，环境的转移概率、奖励函数往很难得知，甚至很难得知环境中有多少状态。若学习算法不再依赖于环境建模，则称为 免模型学习 ，蒙特卡洛强化学习就是其中的一种。蒙特卡洛强化学习使用多次采样，然后求取平均累计奖赏作为期望累计奖赏的近似。蒙特卡洛强化学习算法需要采样一个完整的轨迹来更新值函数，效率较低， 此外 该算法没有充分利用强化学习任务的序贯决策结构。  Q-learning算法结合了动态规划与蒙特卡洛方的思想，使得学习更加高效。传统强化学习：真实环境中的状态数目过多，求解困难。深度 强化 学习：将 深度学习和强化学习结合在 一起，通过深度神经网络 直接学习环境（或观察）与状态动作值函数 Q( s,a )之间的映射关系，简化问题的求解。 </p>
<p>强化学习：以TensorFlow实现Flappy bird游戏的自主学习的实例。</p>

<hr />

<p>from sklearn.cross_validation import train_test_split，例如X_train, X_test, y_train, y_test = train_test_split( X, y, test_size=0.25)</p>
<p>from sklearn.datasets import fetch_lfw_people，例如lfw_people = fetch_lfw_people(min_faces_per_person=70, resize=0.4)</p>
<p>from sklearn.grid_search import GridSearchCV<，例如clf = GridSearchCV(SVC(kernel='rbf', class_weight='auto'), param_grid)/p>
<p>from sklearn.metrics import classification_report，例如print(classification_report(y_test, y_pred, target_names=target_names))</p>
<p>from sklearn.metrics import confusion_matrix，例如print(confusion_matrix(y_test, y_pred, labels=range(n_classes)))</p>
<p>from sklearn.decomposition import RandomizedPCA，例如pca = RandomizedPCA(n_components=n_components, whiten=True).fit(X_train)</p>
<p>from sklearn.svm import SVC</p>

<hr />

<p>基于sklearn的KNN</p>
<p>from sklearn import neighbors</p>
<p>from sklearn import datasets</p>
<p>knn = neighbors.KNeighborsClassifier()</p>
<p>iris = datasets.load_iris()</p>
<p>print iris</p>
<p>knn.fit(iris.data, iris.target)</p>
<p>predictedLabel = knn.predict([[0.1, 0.2, 0.3, 0.4]])</p>
<p>print predictedLabel</p>


<hr />

<p>基于sklearn的svm</p>
<p>from sklearn import svm</p>
<p>X = [[2, 0], [1, 1], [2,3]]</p>
<p>y = [0, 0, 1]</p>
<p>clf = svm.SVC(kernel = 'linear')</p>
<p>clf.fit(X, y)  </p>
<p>print clf</p>
<p>print clf.support_vectors_ # get support vectors</p>
<p>print clf.support_  # get indices of support vectors</p>
<p>print clf.n_support_  # get number of support vectors for each class</p>


<hr />

<p>作者：无名氏。</p>



</article>
<footer>
    <a href="/homepage/views/posts" class="js_goto_posts">返回目录 - 痕迹</a>
</footer>
<div class="browser js_browser">
    <img src="" />
</div>

<script src="/homepage/assets/script/main.js"></script>
</body>
</html>
